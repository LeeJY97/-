# 그리디: 큰 수의 법칙

[전체 코드](./큰수의법칙.py)

## 문제

```
다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙.
단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없음.

예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정.
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.

단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어 순서대로 3, 4, 3, 4, 3 으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로 4 + 4 + 4 + 4 ... = 28이 도출

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 큰 수의 법칙에 따른 결과를 출력하시오.
```

## 풀이

#### 1. 배열 정렬 후 큰 수 2개를 변수로 선언

```py
arr.sort()

first, second = arr[-1], arr[-2]
```

문제를 잘 보면 `K`만큼만 더할 수 있고, 다른 수를 더한 후 다시 가장 큰 수를 더할 수 있다고 나온다.  
한 번 더한 수를 다시 더할 수 있다. 즉, 가장 큰 수와 두 번째로 큰 수만 번갈아서 더하면 되기 때문에  
배열에서 1, 2 번째로 큰 수만 사용하면 된다.

---

#### 2. M만큼 전체 반복

```py
  while True:
    # 기타 코드 생략 . . .
    if M == 0:
      break
    M -= 1

  return result
```

우선 반복문을 만든다. `M`이 0인 경우 다음 스텝을 진행하지 않고 반복문을 탈출한다. 즉, M 만큼만 반복해서 더한다.

---

#### 3. K만큼 가장 큰 수를 더하고, 두 번쨰로 큰 수 한 번 더하기 (반복해서)

```py
  result = 0
  while True:
    for _ in range(K):
      if M == 0:
        break
      result+=first
      M -= 1
    if M == 0:
      break
    result+=second
    M -= 1

  return result
```

**가장 큰 수 더하기**  
전체 반복문 내에 `K` 만큼 반복하는 중첩 반복문 생성. 해당 반복문은 첫 번째로 큰 수를 `result`에 더함.

**두 번째로 큰 수 더하기**  
`K` 반복문이 끝난 뒤 두 번째로 큰 수를 더함

공통적으로 `M을 -1` 씩 처리하고 M이 0일 경우 반복문을 탈출하도록 조건 처리
